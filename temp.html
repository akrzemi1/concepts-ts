
<cxx-clause id="temp">
  <h1>Templates</h1>

  <p>Modify the <cxx-grammarterm>template-declaration</cxx-grammarterm>
  grammar in <cxx-ref in="cxx" to="temp"></cxx-ref>.</p>

  <bnf-grammar>
    <bnf-rule>template-declaration</bnf-rule>
      <bnf-alt>
        <bnf-terminal>template</bnf-terminal>
        <bnf-terminal>&lt;</bnf-terminal>
        template-parameter-list
        <bnf-terminal>&gt;</bnf-terminal>
        <ins><bnf-opt>requires-clause</bnf-opt></bnf-alt></ins>
      </bnf-alt>
      <bnf-alt>
        concept
        <bnf-terminal>{</bnf-terminal>
        introduction-list
        <bnf-terminal>}</bnf-terminal>
      </bnf-alt>

    <bnf-rule>requires-clause</bnf-rule>
      <bnf-alt><bnf-terminal>requires</bnf-terminal> constraint-expression</bnf-alt>

      <bnf-rule>concept</bnf-rule>
        <bnf-alt><bnf-opt>nested-name-specifier</bnf-opt> concept-name</bnf-alt>

      <bnf-rule>introduction-list</bnf-rule>
        <bnf-alt>identifier</bnf-alt>
        <bnf-alt>introduction-list <bnf-terminal>,</bnf-terminal> identifier</bnf-alt>
    </ins>
  </bnf-grammar>

  <p>Add the following paragraphs after 
  <cxx-ref in="cxx" to="temp"></cxx-ref>/6.</p>

  <p>A <cxx-grammarterm>requires-clause</cxx-grammarterm> associates a
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> with the
  template declaration.</p>

  <p>A <cxx-grammarterm>template-declaration</cxx-grammarterm> is written in
  terms of its <cxx-grammarterm>template-parameters</cxx-grammarterm>. These
  parameters are declared explicitly in a
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm>
  (<cxx-ref to="temp.param"></cxx-ref>), or they are
  introduced by a <cxx-grammarterm>concept</cxx-grammarterm> and its
  <cxx-grammarterm>introduction-list</cxx-grammarterm>.

  In the latter case, each <cxx-grammarterm>identifier</cxx-grammarterm>
  in the <cxx-grammarterm>introduction-list</cxx-grammarterm> is declared
  to be a template parameter. Each template parameter shall match in kind
  the corresponding template parameter of the concept definition designated by
  the <cxx-grammarterm>concept</cxx-grammarterm>.

  If, after lookup, the <cxx-grammarterm>concept</cxx-grammarterm> designates
  an overloaded set of concept functions, the designated concept is the
  one with the same number of template parameters as the number of
  <cxx-grammarterm>identifier</cxx-grammarterm> in the
  <cxx-grammarterm>introduction-list</cxx-grammarterm>.

  <!--
  In the latter case, the <cxx-grammarterm>concept-name</cxx-grammarterm> of
  the <cxx-grammarterm>concept</cxx-grammarterm> shall refer to the
  concept declaration, called the <dfn>introducing concept</dfn>, having the 
  same number of template parameters as the number of 
  <cxx-grammarterm>identifier</cxx-grammarterm>s in
  <cxx-grammarterm>introduction-list</cxx-grammarterm>. 
  
  Each <cxx-grammarterm>identifier</cxx-grammarterm> in the 
  <cxx-grammarterm>introduction-list</cxx-grammarterm> is declared to be
  a template parameter, called an <dfn>introduced template parameter</dfn>, 
  whose kind matches the corresponding template parameter in the introducing 
  concept.
  -->

  The introduction of template parameters by a 
  <cxx-grammarterm>concept</cxx-grammarterm> constrains the template 
  declaration. This constraint is a
  <cxx-grammarterm>template-id</cxx-grammarterm> whose
  <cxx-grammarterm>template-name</cxx-grammarterm> is that of the
  introducing <cxx-grammarterm>concept</cxx-grammarterm> and whose template 
  arguments are the introduced template parameters. If the introducing concept 
  is a function concept, the constraint is a function call with no function 
  arguments. The constraint is associated with the template declaration.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T, int N, typename... Xs&gt;
  concept bool Inscrutable() { ... };

Mergeable{A, B, C} struct s;
  </cxx-codeblock>
  This class template declaration of <code>s</code> is equivalent to:
  <cxx-codeblock>
template&lt;typename A, int B, typename... C&gt;
  requires Inscrutable&lt;A, B, C&gt;()
    struct s;
  </cxx-codeblock>
  The introduced parameter <code>C</code> is a template parameter pack.
  </cxx-example>
  </p>

  <p>
  <cxx-note>A template parameter with a default argument does not introduce
  omitted identifiers. This would cause the introduction of an unnamed and 
  unusable template parameter in the template declaration. 
  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T1, typename T2, typename T3 = T2&gt;
  concept bool Ineffable() { ... };

Ineffable{X, Y} void f();    // Error: not all parameters are introduced
  </cxx-codeblock>
  </cxx-example>
  </cxx-note>
  </p>

  <p>If a constrained declaration is introduced by a concept 
  introduction, then all its declarations must have the same 
  form.</p>


  <p>A template declaration's <dfn>associated constraints</dfn> are
  the conjunction (logical and) of all 
  <cxx-grammarterm>constraint-expression</cxx-grammarterm>s introduced
  by:
  <ul>
  <li><cxx-grammarterm>constrained-parameter</cxx-grammarterm>s in a
    <cxx-grammarterm>template-parameter-list</cxx-grammarterm>,</li>

  <li>a <cxx-grammarterm>requires-clause</cxx-grammarterm> following a
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm>, </li>

  <li>introduction by a concept (<cxx-ref to="temp"></cxx-ref>),</li>

  <li><cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s in
    a <cxx-grammarterm>declarator</cxx-grammarterm>, and</li>

  <li>a <cxx-grammarterm>requires-clause</cxx-grammarterm> in an
  <cxx-grammarterm>init-declarator</cxx-grammarterm>,
  <cxx-grammarterm>member-declarator</cxx-grammarterm>, or
  <cxx-grammarterm>function-definition</cxx-grammarterm>.</li>
  </ul>
  <cxx-note>
  A template's associated constraints form a constraint 
  expression (<cxx-ref to="temp.constr"></cxx-ref>).
  </cxx-note>
  <!-- </p> -->

<!-- 
  <p>A templates constraints must be satisfied 
  (<cxx-ref to="temp.constr"></cxx-ref>) in order for the corresponding
  definition to be instantiated.


  odr-used within the program. A program that uses a template
  specialization whose constraints cannot be satisfied is ill-formed.</p>

  Class template, alias template, and variable template constraints 
  are checked during name lookup (<cxx-ref to="temp.names"></cxx-ref>); 
  function template constraints and class template partial specialization 
  constraints are checked during template argument deduction
  (<cxx-ref to="temp.deduct"></cxx-ref>).</p>

  <p>Any usage of a constrained template in a template declaration 
  is ill-formed unless the associated constraints of the constrained 
  template are subsumed by the associated constraints of template 
  parameter. No diagnostic is required.
  </p> -->


  <cxx-section id="temp.param">
    <h1>Template parameters</h1>

    <p>Modify the <cxx-grammarterm>template-parameter</cxx-grammarterm>
    grammar in <cxx-ref in="cxx" to="temp.param"></cxx-ref> to include
    <cxx-grammarterm>constrained-parameter</cxx-grammarterm>.

    <bnf-grammar>
      <bnf-rule>template-parameter</bnf-rule>
        <ins><bnf-alt>constrained-parameter</bnf-alt></ins>

      <ins>
      <bnf-rule>constrained-parameter</bnf-rule>
        <bnf-alt>
          attribute-specifier-seq<bnf-opt></bnf-opt>
          decl-specifier-seq
          declarator
        </bnf-alt>
        
        <bnf-alt>
          attribute-specifier-seq<bnf-opt></bnf-opt>
          decl-specifier-seq
          declarator
          <bnf-terminal>=</bnf-terminal>
          constrained-initializer
        </bnf-alt>

        <bnf-alt>
          attribute-specifier-seq<bnf-opt></bnf-opt>
          decl-specifier-seq
          abstract-declarator<bnf-opt></bnf-opt>
        </bnf-alt>
        
        <bnf-alt>
          attribute-specifier-seq<bnf-opt></bnf-opt>
          decl-specifier-seq
          abstract-declarator<bnf-opt></bnf-opt>
          <bnf-terminal>=</bnf-terminal>
          constrained-initializer
        </bnf-alt>

      <bnf-rule>constrained-initializer</bnf-rule>
        <bnf-alt>type-id</bnf-alt>
        <bnf-alt>initializer-clause</bnf-alt>
      </ins>
    </bnf-grammar>

    <cxx-note> 
    The <cxx-grammarterm>constrained-parameter</cxx-grammarterm>
    syntax is largely identical to the
    <cxx-grammarterm>parameter-declaration</cxx-grammarterm> syntax except
    syntax of default arguments, which is extended to also accept a 
    <cxx-grammarterm>type-id</cxx-grammarterm>.
    </cxx-note>

    <p>Add the following paragraphs after
    <cxx-ref in="cxx" to="temp.param"></cxx-ref>/15.</p>

    <p>A <dfn>constrained template parameter</dfn> is a
    <cxx-grammarterm>constrained-parameter</cxx-grammarterm> whose
    <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> contains a
    <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.

    A <cxx-grammarterm>constrained-parameter</cxx-grammarterm> 
    defines its identifier to be a template parameter that matches in
    kind the first template parameter, called the <dfn>prototype parameter</dfn>, 
    of the concept declaration designated by the 
    <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.

    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T&gt; 
  concept bool C1 = ...;
template&lt;template&lt;typename&gt; class X&gt; 
  concept bool C2 = ...;
template&lt;int N&gt; 
  concept bool P = ...;

template&lt;C1 T&gt; void f();       // T is a type parameter
template&lt;C2 X&gt; void g();       // X is a template with one type parameter
template&lt;P N&gt; void x();        // N has type int
template&lt;const P* N&gt; void y(); // N has type const int*
    </cxx-codeblock>
    </cxx-example>
    </p>

    <p>
    The declared <cxx-grammarterm>template-parameter</cxx-grammarterm> is
    a template parameter pack if the prototype parameter declares a
    template parameter pack. In such cases, the 
    <cxx-grammarterm>declarator-id</cxx-grammarterm> or
    <cxx-grammarterm>abstract-declarator</cxx-grammarterm> of the
    <cxx-grammarterm>constrained-parameter</cxx-grammarterm> shall
    also include an ellipsis.
    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename... Ts&gt;
  concept bool X = ...;

template&lt;X... Xs&gt; void f(); // Xs is a parameter pack
template&lt;X Xs&gt; void g();    // Error: must X must include ...
    </cxx-codeblock>
    </cxx-example>
    </p>

    <p>If the <cxx-grammarterm>constrained-parameter</cxx-grammarterm>
    declares a type parameter, then the 
    <cxx-grammarterm>constrained-initializer</cxx-grammarterm>
    is parsed as a <cxx-grammarterm>type-id</cxx-grammarterm>. Otherwise, it
    is parsed as a <cxx-grammarterm>initializer-clause</cxx-grammarterm>.
    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;C1 T = int&gt; void p(); // Ok
template&lt;P N = 0&gt; void q();    // Ok
template&lt;P M = int&gt; void r();  // Error: int is not an expression
    </cxx-codeblock>
    </cxx-example>
    </p>

    <p>The declaration of a 
    <cxx-grammarterm>constrained-parameter</cxx-grammarterm> 
    introduces a new constraint on the template declaration. 

    The constraint is formed by substituting the declared 
    <cxx-grammarterm>template-parameter</cxx-grammarterm> as the first
    template argument of the concept declaration designated by the
    <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> in
    the <cxx-grammarterm>constrained-parameter</cxx-grammarterm> declaration.

    If the <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> is
    a <cxx-grammarterm>partial-concept-id</cxx-grammarterm>, its template
    arguments are substituted after the declared
    <cxx-grammarterm>template-parameter</cxx-grammarterm>.

    If the designated concept is a function concept, then the 
    introduced constraint is a function call.
    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;C1 T&gt; void f1(); // requires C1&lt;T&gt;
template&lt;C2 U&gt; void f2(); // requires C2&lt;U&gt;
template&lt;P N&gt; void f3(); // requires P&lt;N&gt;
    </cxx-codeblock>
    </cxx-example>
    </p>

    <p>If the <cxx-grammarterm>constrained-parameter</cxx-grammarterm> declares 
    a template parameter pack, the formation of the constraint depends on 
    whether the designated concept designated by the parameter's
    <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> is variadic.

    Let <code>T</code> be the declared parameter, <code>C</code> be the
    designated concept, and <code>Args...</code> be a  sequence of template
    arguments from a <cxx-grammarterm>partial-concept-id</cxx-grammarterm>,
    possibly empty.

    If <code>C</code> is a variadic concept, then the associated constraint
    is a <cxx-grammarterm>template-id</cxx-grammarterm> of the form
    <code>C&lt;T..., Args...&gt;</code>. 

    Otherwise, if <code>C</code> is not a variadic concept, the associated
    constraint is a conjunction of sub-constraints
    <code>C&lt;T<i>i</i>, Args...&gt;</code> for each <code>T<i>i</i></code>
    in the parameter pack <code>T</code>.

    If <code>C</code> is a function concept, each introduced constraint or
    sub-constraint is adjusted to be a call expression of the form
    <code>C&lt;X, Args...&gt;()</code> where <code>X</code> is either
    the template parameter pack <code>T</code> or an element 
    <code>T<i>i</i></code>.
    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename... Ts&gt; concept bool P = ...;
template&lt;typename T> concept bool U = ...;


template&lt;P... Xs&gt; void f4();   // requires P&lt;Xs...&gt;
template&lt;U... Args&gt; void f5(); // requires U&lt;Args0&gt; && U&lt;Args1&gt; && ... && U&lt;Argsn&gt;
    </cxx-codeblock>
    Here, <code>Args0</code>, <code>Args1</code>, etc. denote elements
    of the template argument pack <code>Args</code> used as part of the
    introduced constraint.
    </cxx-example>
    </p>
  </cxx-section>

  <!-- FIXME: Check that this is in an appropriate place. -->
  <cxx-section id="temp.names">
    <h1>Template names</h1>

    <p>Insert the following paragraphs after 
    <cxx-ref in="cxx" to="temp.names"></cxx-ref>/7.</p>

    <p>If a <cxx-grammarterm>template-id</cxx-grammarterm> refers to a
    specialization of a constrained template declaration, the template's
    associated constraints are checked by substituting the
    <cxx-grammarterm>template-arguments</cxx-grammarterm> into the
    constraints and evaluating the resulting expression. If the substitution 
    results in an invalid type or expression, or if the associated constraints 
    evaluate to <code>false</code>, then the program is ill-formed.
    <cxx-example>
    <cxx-codeblock>
template&lt;typename T&gt; concept bool True = true;
template&lt;typename T&gt; concept bool False = false;

template&lt;False T&gt; struct S;
template&lt;True T&gt; using Ptr = T*;

S&lt;int&gt;* x;   // Error: int does not satisfy the constraints of False.
Ptr&lt;int&gt; z;  // Ok: z has type int*
    </cxx-codeblock>
    </cxx-example>
    <cxx-note>
    Checking the constraints of a constrained class template does not 
    require its instantiation. 
    This guarantees that a partial specialization cannot be less 
    specialized than a primary template. This requirement is enforced
    during name lookup, not when the partial specialization is declared.
    </cxx-note>
    </p>

    </cxx-note>
    </p>
  </cxx-section> <!-- temp.names -->

  <cxx-section id="temp.arg">
    <h1>Template arguments</h1>

    <cxx-section id="temp.arg.template">
      <h1>Template template arguments</h1>

      <p>Modify <cxx-ref in="cxx" to="temp.arg.template"></cxx-ref>.

      <p>A <cxx-grammarterm>template-argument</cxx-grammarterm> matches 
      a template <cxx-grammarterm>template-parameter</cxx-grammarterm> 
      (call it <code>P</code>) when each of the template parameters in 
      the <cxx-grammarterm>template-parameter-list</cxx-grammarterm> of 
      the <cxx-grammarterm>template-argument</cxx-grammarterm>'s 
      corresponding class template or alias template (call it 
      <code>A</code>) matches the corresponding template parameter in 
      the <cxx-grammarterm>template-parameter-list</cxx-grammarterm> of 
      <code>P</code><ins>, and the associated constraints of <code>P</code> 
      shall subsume the associated constraints of <code>A</code>
      (<cxx-ref to="temp.constr"></cxx-ref>)</ins>.
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt;
  concept bool X = has_x&lt;T&gt;::value;
template&lt;typename T&gt;
  concept bool Y = X&lt;T&gt; && has_y&lt;T&gt;::value;
template&lt;typename T&gt;
  concept bool Z = Y&lt;T&gt; && has_z&lt;T&gt;::value;

template&lt;template&lt;Y&gt; class C&gt;
  class temp { ... };

template&lt;X T&gt; class x;
template&lt;Z T&gt; class z;

temp&lt;x&gt; s1; // Ok: X is subsumed by Y
temp&lt;z&gt; s2; // error: Z subsumes Y
      </cxx-codeblock>
      </cxx-example>
      </p>

    </cxx-section> <!-- temp.arg.template -->
  </cxx-section> <!-- tmep.arg -->

  <cxx-section id="temp.decls">
    <h1>Template declarations</h1>

    <cxx-section id="temp.class">
      <h1>Class templates</h1>


      <p>Insert the following paragraph after 
      <cxx-ref in="cxx" to="temp.class"></cxx-ref>/3.</p>

      <p>When a member of a constrained class template is defined outside of 
      its class template definition, it shall be specified with the
      <cxx-grammarterm>template-parameters</cxx-grammarterm> and
      associated constraints of the class template.
      <cxx-example>
      <cxx-codeblock>
template&lt;typename T&gt; concept bool Con = ...;

template&lt;typename T&gt; requires Con&lt;T&gt;
  struct S {
    void f();
    void g();
  }

template&lt;typename T&gt; 
  requires Con&lt;T&gt;
    void S&lt;T&gt;::f() { } // Ok: parameters and constraints match

template&lt;typename T&gt;
  void S&lt;T&gt;::g() { } // Error: no declaration of g() in S&lt;T&gt;
      </cxx-codeblock>
      </cxx-example>
      </p>


      <cxx-section id="temp.mem.func">
        <h1>Member functions of class templates</h1>

        <p>Add the following paragraphs after
        <cxx-ref in="cxx" to="temp.mem.func"></cxx-ref>.
        
        <p>A member function of a class template whose declarator contains a
        <cxx-grammarterm>requires-clause</cxx-grammarterm> is a
        <dfn>constrained member function</dfn>.
        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt;
  class S {
    void f() requires C&lt;T&gt;();
  };
        </cxx-codeblock>
        </cxx-example>
        </p>

        <p>Constraints on member functions are instantiated as needed
        during overload resolution, not when the class template is
        instantiated
        (<cxx-ref in="cxx" to="temp.inst"></cxx-ref>).
        <cxx-note>
        Constraints on member functions do not affect the declared 
        interface of a class. That is, a constrained copy constructor 
        is still a copy constructor, even if it will not be viable for 
        a specialization of the class template.
        </cxx-note>
        </p>

        <p>A constrained member function of a class template may be defined
        outside of its class template definition. Its definition shall be
        specified with the constraints of its declaration.
        <cxx-example>
        Consider possible definitions of the constrained member function 
        <code>S&lt;T&gt;f</code> from above.
        <cxx-codeblock>
template&lt;typenamae T&gt; 
  void S&lt;T&gt;::f() { }                 // Error: no declaration of f() in S&lt;T&gt;.

template&lt;typenamae T&gt; 
  void S&lt;T&gt;::f() requires C&lt;T&gt;() { } // Ok: defines S&lt;T&gt;::f
        </cxx-codeblock>
        </cxx-example>
        </p>

      </cxx-section> <!-- temp.mem.func -->
    </cxx-section> <!-- temp.class -->


    <cxx-section id="temp.mem">
      <h1>Member templates</h1>

      <p>Insert the following paragraph after
      <cxx-ref in="cxx" to="temp.mem"></cxx-ref>/1.</p>

      <p>A constrained member template defined outside of its class template 
      definition shall be specified with the
      <cxx-grammarterm>template-parameter</cxx-grammarterm>s 
      and constraints of the class template followed by
      the template parameters and constraints of the member template.
      <cxx-example>
      <cxx-codeblock>
template&lt;typename T&gt; concept bool Foo = ...;
template&lt;typename T&gt; concept bool Bar = ...; // Different than Foo

template&lt;Foo T&gt;
  struct S {
    template&lt;Bar U&gt; void f(U);
    template&lt;Bar U&gt; void g(U);
  };

template&lt;Foo T&gt; template&lt;Bar U&gt; void S&lt;T&gt;::f(U); // Ok
template&lt;Foo T&gt; template&lt;Foo U&gt; void S&lt;T&gt;::g(U); // Error: no g() declared in S
      </cxx-codeblock>
      The template constraints in the definition of <code>g</code> do not
      match those in its declaration.
      </cxx-example>
      </p>
    </cxx-section> <!-- temp.mem -->


    <cxx-section id="temp.friend">
      <h1>Friends</h1>

      <p>Add the following paragraphs after
      <cxx-ref in="cxx" to="temp.friend"></cxx-ref>/9.

      <p> 
      A <dfn>constrained friend</dfn> is a friend of a class 
      template with associated constraints.

      A constrained friend can be a constrained class template, 
      constrained function template, or an ordinary (non-template) 
      function.
      
      <!-- TODO: What is shorthand? -->
      Constraints on template friends are written using shorthand, 
      introductions, or a requires clause following the 
      <cxx-grammarterm>template-parameter-list</cxx-grammarterm>.

      Constraints on non-template friend functions are written 
      after the result type.
      <cxx-example class="inline">
      When <code>C</code> is a type concept, all of the following are valid 
      constrained friend declarations.
      <cxx-codeblock>
template&lt;typename T&gt;
  struct X {
    template&lt;C U&gt;
      friend void f(X x, U u) { }

    template&lt;C W&gt;
      friend struct Z { };

    friend bool operator==(X a, X b) requires C&lt;T&gt;() {
      return true;
    }
  };
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>
      A non-template friend function shall not be constrained unless 
      the function's parameter or result type depends on a template 
      parameter.
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt;
  struct S {
    friend void f(int n) requires C&lt;T&gt;(); // Error: cannot be constrained
  };
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>
      A constrained non-template friend function shall not declare 
      a specialization.
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt;
  struct S {
    friend void f&lt;&gt;(T x) requires C&lt;T&gt;(); // Error: declares a specialization

    friend void g(T x) requires C&lt;T&gt;() { } // OK: does not declare a specialization
  };
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>
      As with constrained member functions, constraints on non-template friend
      functions are not instantiated during class template instantiation.
      </p>

    </cxx-section> <!-- temp.firend -->

    <cxx-section id="temp.class.spec">
      <h1>Class template partial specialization</h1>

      <cxx-section id="temp.class.spec.match">
        <h1>Matching of class template partial specializations</h1>

        <p>Modify 
        <cxx-ref in="cxx" to="temp.class.spec.match"></cxx-ref>/2.</p>

        <p> A partial specialization matches a given actual template 
        argument list if the template arguments of the partial 
        specialization can be deduced from the actual template argument 
        list (<cxx-ref in="cxx" to="temp.deduct"></cxx-ref>)
        <ins>, and the deduced template arguments satisfy the constraints 
        of the partial specialization, if any 
        (<cxx-ref to="temp.constr"></cxx-ref>)</ins>.</p>

      </cxx-section> <!-- temp.class.spec.match -->

      <cxx-section id="temp.class.order">
        <h1>Partial ordering of class template specializations</h1>

        <p>Modify 
        <cxx-ref in="cxx" to="temp.class.order"></cxx-ref>/1.</p>

        <p>
        For two class template partial specializations, the first is 
        at least as specialized as the second if, given the following 
        rewrite to two function templates, the first function template 
        is at least as specialized as the second according to the ordering 
        rules for function templates 
        (<cxx-ref in="cxx" to="temp.func.order"></cxx-ref>):
        </p>
        <ul>
          <li> the first function template has the same template 
          parameters <ins>and constraints</ins> as the first partial 
          specialization and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the first partial specialization, and</li>

          <li> the second function template has the same template 
          parameters <ins>and constraints</ins> as the second partial 
          specialization and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the second partial specialization.</li>
        </ul>
        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt;
  concept bool Integer = is_integral&lt;T&gt;::value;
template&lt;typename T&gt;
  concept bool Unsigned_integer = Integer&lt;T&gt; &amp;&amp; is_unsigned&lt;T&gt;::value;

template&lt;typename T&gt; class S { };
template&lt;Integer T&gt; class S&lt;T&gt; { };          // #1
template&lt;Unsigned_integer T&gt; class S&lt;T&gt; { }; // #2

template&lt;Integer T&gt; void f(S&lt;T&gt;);          // A
template&lt;Unsigned_integer T&gt; void f(S&lt;T&gt;); // B
        </cxx-codeblock>
        The partial specialization #2 will be more specialized than 
        #1 for template arguments that satisfy both constraints because 
        <code>B</code> will be more specialized than <code>A</code>.
        </cxx-example>

      </cxx-section> <!-- temp.class.order -->
    </cxx-section> <!-- temp.class.spec -->

    <cxx-section id="temp.fct">
      <h1>Function templates</h1>

      <cxx-section id="temp.deduct">
        <h1>Template argument deduction</h1>

        <p>Immediately after
        <cxx-ref in="cxx" to="temp.deduct"></cxx-ref>/5, add the following
        paragraph:</p>

        <p>If the template has associated constraints, the template arguments
        are substituted into those associated constraints and evaluated.
        If the substitution results in an invalid type or expression, or
        if the associated constraints evaluate to <code>false</code>,
        type deduction fails.</p>

      </cxx-section> <!-- temp.deduct -->

      <cxx-section id="temp.over.link">
        <h1>Function template overloading</h1>

        <p>Modify <cxx-ref in="cxx" to="temp.over.link"></cxx-ref>/6.</p>

        <p>
        A function template can be overloaded either by (non-template) 
        functions of its name or by (other) function templates of the 
        same name. When a call to that name is written (explicitly, or 
        implicitly using the operator notation), template argument deduction 
        <cxx-ref to="temp.deduct"></cxx-ref><ins>,</ins> <del>and</del> 
        checking of any explicit template arguments 
        <cxx-ref in="cxx" to"temp.arg"></cxx-ref> <ins>, and checking of 
        associated constraints <cxx-ref to="temp.constr"></cxx-ref></ins>
        are performed for each function template to find the template 
        argument values (if any) that can be used with that function 
        template to instantiate a function template specialization that 
        can be invoked with the call arguments. 

        For each function template, if the argument deduction and 
        checking succeeds, the template-arguments (deduced and/or 
        explicit) are used to synthesize the declaration of a single 
        function template specialization which is added to the 
        candidate functions set to be used in overload resolution. If, 
        for a given function template, argument deduction fails, no 
        such function is added to the set of candidate functions for 
        that template.

        The complete set of candidate functions includes all the 
        synthesized declarations and all of the non-template overloaded 
        functions of the same name. The synthesized declarations are 
        treated like any other functions in the remainder of overload 
        resolution, except as explicitly noted in 
        <cxx-ref in="cxx" to"over.match"></cxx-ref>.
        </p>

        <p>Modify <cxx-ref in="cxx" to="temp.over.link">/6.</cxx-ref>

        <p>
        Two function templates are <dfn>equivalent</dfn> if they are 
        declared in the same scope, have the same name, have identical 
        template parameter lists, <del>and</del> have return types<ins>,</ins> 
        <del>and</del> parameter lists, <ins>and constraints 
        <cxx-ref to="temp.constr"></cxx-ref></ins> that are equivalent 
        using the rules described above to compare expressions involving 
        template parameters.
        </p>

      </cxx-section> <!-- temp.over.link -->

      <cxx-section id="temp.func.order">
        <h1>Partial ordering of function templates</h1>

        <p>Modify <cxx-ref in="cxx" to="temp.func.order"></cxx-ref>/2.</p>

        <p>
        Partial ordering selects which of two function templates is 
        more specialized than the other by transforming each template 
        in turn (see next paragraph) and performing template argument 
        deduction using the function type. The deduction process 
        determines whether one of the templates is more specialized 
        than the other.

        If so, the more specialized template is the one chosen by the 
        partial ordering process. <ins>If the two templates have 
        identical template parameter lists and equivalent return types 
        and parameter lists, then partial ordering selects the template 
        whose associated constraints subsume but are not equivalent to 
        the associated constraints of the other 
        <cxx-ref to="temp.constr"></cxx-ref>. 

        A constrained template is always selected over an unconstrained 
        template.</ins>
        </p>

      </cxx-section> <!-- temp.func.order -->
    </cxx-section> <!-- temp.fct -->
  </cxx-section> <!-- temp.decls -->

  <cxx-section id="temp.spec">
    <h1>Template instantiation and specialization</h1>

    <cxx-section id="temp.inst">
      <h1>Implicit instantiation</h1>

      <p>Insert the following pargraph after 
      <cxx-ref in="cxx" to="temp.inst"></cxx-ref>/1.</p>

      <p>The implicit instantiation of a class template does not cause
      the instantiation of the associated constraints of constrained member 
      functions.</p>
    </cxx-section> <!-- temp.inst -->

    <cxx-section id="temp.explicit">
      <h1>Explicit instantiation</h1>

      <p>Insert the following paragraph under 
      <cxx-ref in="cxx" to="temp.explicit"></cxx-ref>.</p>

      <p>An explicit instantiation of constrained template declaration
      (<cxx-ref to="temp"></cxx-ref>)
      or constrained member function declaration 
      (<cxx-ref to="temp.mem.func"></cxx-ref>)
      shall satsify the associated constraints of that declaration
      (<cxx-ref to="temp.constr"></cxx-ref>).
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typname T&gt;
  concept bool C = requires(T t) { t.c(); }s

template&lt;typenane T&gt;
  requires C&lt;T&gt;
    struct X { }

template struct X&lt;int&gt;; // Error: int does not satisfy C.
      </cxx-codeblock>
      </cxx-example>
      </p>
    </cxx-section> <!-- temp.explicit -->
  </cxx-section> <!-- temp.spec -->


  <cxx-section id="temp.constr">
    <h1>Template constraints</h1>

    <p>Add this as a new section under 
    <cxx-ref in="cxx" to="temp">"</cxx-ref>.</p>


    <p>Certain contexts require expressions that satisfy additional
    requirements as detailed in this sub-clause. Expressions that 
    satisfy these requirements are called 
    <dfn>constraint expression</dfn>s or simply 
    <dfn>constraint</dfn>s.
    <bnf-grammar>
      <bnf-rule>constraint-expression</bnf-rule>
        <bnf-alt>logical-or-expression</bnf-alt>
    </bnf-grammar>

    <p>A <cxx-grammarterm>logical-or-expression</cxx-grammarterm> is a
    <cxx-grammarterm>constraint-expression</cxx-grammarterm> if, after 
    substituting template arguments, the resulting expression
    <ul>
    <li>is a constant expression,</li>
    <li>has type <code>bool</code>, and</li>
    <li>both operands <code>P</code> and <code>Q</code> in every subexpression
    of a constraint of the form <code>P || Q</code> or <code>P &amp;&amp; Q</code> 
    have type <code>bool</code>.</li>
    </ul>
    <cxx-note>
    A <cxx-grammarterm>constraint-expression</cxx-grammarterm> 
    defines a subset of constant expressions over which certain 
    logical implications can be proven during translation.
    The requirement that operands to logical operators have type
    <code>bool</code> prevents constraint expressions from finding
    user-defined overloads of those operators and possibly subverting the
    logical processing required by constraints.
    </cxx-note>
    <!-- </p> -->

    <p>A program that includes an expression not satisfying these requirements
    in a context where a <cxx-grammarterm>constraint-expression</cxx-grammarterm>
    is required is ill-formed.</p>

    <p>
    <cxx-example>
    Let <code>T</code> be a dependent type, <code>C</code> be a unary function 
    concept, <code>P</code>, <code>Q</code>, and <code>R</code> be 
    value-dependent expressions whose type is <code>bool</code>, and 
    <code>M</code> and  <code>N</code> be integral expressions. All of the 
    following expressions can be used as constraints:
    <cxx-codeblock>
C&lt;T&gt;()
has_trait&lt;T&gt;::value // only if value is a bool member
P && Q
P || (Q && R)
M == N              // only if the result type is bool
M < N               // only if the result type is bool
M + N >= 0
P || !(M < N)
true
false
    </cxx-codeblock>
    An expression of the form <code>M + N</code> is not a valid constraint when
    the arguments have type <code>int</code> since the expression's type is not
    <code>bool</code>. Using this expression as a constraint would make the
    program ill-formed.
    </cxx-example>
    </p>

    <p>A subexpression of a
    <cxx-grammarterm>constraint-expression</cxx-grammarterm> that 
    calls a function concept or refers to a variable concept 
    <cxx-ref to="dcl.concept"></cxx-ref> is a <dfn>concept check</dfn>.
    A concept check is not evaluated; it is simplified according to the
    rules described in this sub-clause.</p>

    <p>Certain subexpressions of a
    <cxx-grammarterm>constraint-expression</cxx-grammarterm> are 
    considered <dfn>atomic constraint</dfn>s. A constraint is atomic 
    if it is not:
    <ul>
    <li>a <cxx-grammarterm>logical-or-expression</cxx-grammarterm> of the form
        <code>P || Q</code>,</li>
    <li>a <cxx-grammarterm>logical-and-expression</cxx-grammarterm> of the form
        <code>P && Q</code>,</li>
    <li>a concept check,</li>
    <li>a <cxx-grammarterm>requires-expression</cxx-grammarterm>, or</li>
    <li>a subexpression of an atomic constraint.</li>
    </ul>
    The valid expression constraints, valid type constraints,
    result type constraints, and exception constraints introduced
    by a <cxx-grammarterm>requires-clause</cxx-grammarterm> are
    also atomic constraints.
    <cxx-example>
    <cxx-codeblock>
has_trait&lt;T&gt;::value
M < N
M + N >= 0
true
false
    </cxx-codeblock>
    </cxx-example>
    <cxx-note>A concept check is not an atomic expression.
    </cxx-note>
    <!-- </p> -->

    <p>Constraints are <dfn>simplified</dfn> by reducing them to 
    expressions containing only logical operators and atomic constraints.
    Concept checks and <cxx-grammarterm>requires-expression</cxx-grammarterm>s 
    are replaced by simplified expressions.
    <cxx-note>
    An implementation is not required to normalize the constraint by rewriting
    in e.g., disjunctive normal form.
    </cxx-note>
    </p>

    <p>A concept check that calls a function concept is simplified by
    substituting the explicit template arguments into the named function
    body's return expression. A concept check that refers to a variable concepts is simplified by substituting the template arguments into the variable's initializer. </p>

    <p>A <cxx-grammarterm>requires-expression</cxx-grammarterm> is simplified
    by replacing it with the conjunction of constraints introduced by
    the <cxx-grammarterm>requirement</cxx-grammarterm>s its 
    <cxx-grammarterm>requirement-list</cxx-grammarterm>.
    <cxx-note>
    Certain atomic constraints introduced by a 
    <cxx-grammarterm>requirement</cxx-grammarterm> have no explicit syntactic 
    representation in the C++.
    </cxx-note>
    </p>
 
    <p>
    <cxx-example>
    Let <code>P</code> and </code>Q</code> be variable templates
    that are atomic constraints.
    <cxx-codeblock>
template&lt;typename T&gt;
  concept bool P_and_Q() { return P&lt;T&gt; &amp;&amp; Q&lt;T&gt;; }

template&lt;typename T&gt;
  concept bool P_or_Q = P&lt;T&gt; || Q&lt;T&gt;;

template&lt;typename T&gt;
  concept bool C = P_and_Q&lt;T&gt; &amp;&amp;
                   requires(T x) { x.p() -&gt; int; };

template&lt;typename X&gt;
  requires P_and_Q&lt;X&gt;() void f();

template&lt;typename X&gt;
  requires P_or_Q&lt;X&gt; void g();

template&lt;typename X&gt;
  requires C&lt;X&gt; void h();
    </cxx-codeblock>
The associated constraints of <code>f</code> are simplified to
the expression <code>P&lt;X&gt; &amp;&amp; Q&lt;X&gt;</code>,
and the associated constraints of <code>g</code> are simplified
to <code>P&lt;X&gt; || Q&lt;X&gt;</code>. The associated constraints
of <code>h</code> are:
<cxx-codeblock>
P&lt;X&gt; &amp;&amp; Q&lt;X&gt;
  &amp;&amp; /* requires x.p() for all x of type X* /
  &amp;&amp; /* requires that x.p() convert to int */
</cxx-codeblock>
    </cxx-example>
    </p>
 <!-- 
    FIXME: Write a bunch of examples.


    <cxx-example class="inline"> 
    The expression 
    <code>x==y &amp;&amp; has_trait&lt;T&gt;::value</code> 
    has two atoms:
    <code>x == y</code> and <code>is_integral&lt;T&gt;::value</code>.
    The expression
    <code>requires(T a, T b) { {a==b} -> bool; }</code> has two atomic
    constraints. <code>a==b</code> must be a valid expression, and
    <code>decltype((a==b)) must be implicitly convertible to <code>bool</code>.
    </cxx-example>
    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T&gt;
  concept bool C() { return sizeof(T) &gt;= 4; }

template&lt;typename T&gt;
  concept bool D = C&lt;T&gt;();

template&lt;typename X&gt;
  requires C&lt;X&gt;() // Processed as sizeof(X) &gt;= 4
void f();

template&lt;typename Q&gt;
  requires D&lt;Q&gt;   // Processed as sizeof(Q) >= 4
void g();
    </cxx-codeblock>
    </cxx-example>
    </p>
 -->


    <p>A constraint is <dfn>satisfied</dfn> if, after substituting template
    arguments, it evaluates to <code>true</code>. Otherwise, the constraint is 
    <dfn>unsatisfied</dfn>.</p>

    <p>
    For a mapping <i>M</i> from a set <i>X</i> of atomic 
    constraints to boolean values, let <i>G(M)</i> be the mapping 
    from constraints to boolean values such that <i>G(M)(C)</i> is 
    the result of substituting each atomic constraint A within 
    <i>C</i> for <i>M(A)</i>.

    For two constraints <code>P</code> and <code>Q</code>, let 
    <i>X</i> be the set of all atomic constraints that
    appear in <code>P</code> and <code>Q</code>.

    <code>P</code> is said to <dfn>subsume</dfn> <code>Q</code> if, for 
    every mapping <i>M</i> from members of <i>X</i> to boolean 
    values for which <i>M(A) = M(B)</i> whenever <i>A</i> and <i>B</i> 
    are equivalent, either <i>G(M)(P)</i> is false or <i>G(M)(Q)</i> is 
    true (or both).
    </p>


    <!--
    FIXME: Write meaningful examples:
    <p>
    Given two constraints <code>P</code> and <code>Q</code> depending 
    on template parameters <code>T1</code>, ..., <code>Tn</code>, 
    <code>P</code> is said to <dfn>subsume</dfn> <code>Q</code> if
    for any template arguments substituted for 
    <code>T1</code>, ..., <code>Tn</code>, the constraint <code>Q</code> 
    is true, then <code>P</code> is also true.
    <cxx-example class="inline">
    Let <code>P</code> be the constraint 
    <code>is_integral&lt;T&gt;::value &amp;&amp; sizeof(T) == 4</code>, 
    and let <code>Q</code> be the constraint <code>sizeof(T) == 4</code>.
    Then <code>P</code> subsumes <code>Q</code>, but <code>Q</code> 
    does not subsume <code>P</code>.
    </cxx-example>
    </p>
    -->

    <p>Two <cxx-grammarterm>constraint-expressions</cxx-grammarterm>
    <code>P</code> and <code>Q</code> are <dfn>logically equivalent</dfn> 
    if and only if <code>P</code> subsumes <code>Q</code> and 
    <code>Q</code> subsumes <code>P</code>. </p>

  </cxx-section> <!-- temp.constr -->

</cxx-clause> <!-- temp -->
